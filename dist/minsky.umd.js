!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.minksy={})}(this,function(e){"use strict";const{List:t,Map:n,Record:s}=require("immutable"),r=0,i=null,o={EMP:"empty",INC:"increment",DEC:"decrement"};class d extends(s({val:null,register:null})){constructor(e,t){if(e<r)throw new Error("val in MinusNode must be greater than or equal to 0");super({val:e,register:t})}}class a extends(s({val:null,register:null})){constructor(e,t){if(e<r)throw new Error("val in MinusNode must be greater than or equal to 0");super({val:e,register:t})}}e.empty=r,e.halt_node=void 0,e.haltNode=i,e.linkType=o,e.RegisterMachine=class extends(s({nodes:n(),registers:n(),links:n(),states:t(),currNode:i})){addNode(e,t){if(t instanceof d)return this.withMutations(function(n){n.setIn(["nodes",e],t),n.setIn(["links",e,o.INC],i),n.setIn(["registers",t.get("register")],null)});if(t instanceof a)return this.withMutations(function(n){n.setIn(["nodes",e],t),n.setIn(["links",e,o.EMP],i),n.setIn(["links",e,o.DEC],i),n.setIn(["registers",t.get("register")],null)});throw new Error(`invalid node type: ${t.constructor.name}`)}addLink(e,t,n){let s=!1;for(let t in o)if(o[t]===e){s=!0;break}if(!s)throw new Error(`invalid transition type: ${e.constructor.name}`);return this.checkNode(t),this.checkNode(n),this.setIn(["links",t,e],n)}checkNode(e){if(!this.nodes.has(e))throw new Error(`register machine does not have node named: ${e}`)}saveState(){return this.update("states",e=>e.push(this.remove("states")))}updateNode(e){const t=this.getIn(["nodes",e,"register"]);if(void 0!==this.getIn(["nodes",e,"val"]))return this;{const n=this.getIn(["registers",t]);this.setIn(["nodes",e,"val"],n)}}increment(e){if(this.checkNode(e),!(this.getIn(["nodes",e])instanceof d))throw new Error(`node can not be incremented: ${e}`);return this.saveState().withMutations(function(t){t.updateNode(e),t.updateIn(["nodes",e,"val"],e=>e+1);const n=t.getIn(["nodes",e,"val"]),s=t.getIn(["nodes",e,"register"]);t.setIn(["registers",s],n);const r=t.getIn(["links",e,o.INC]);t.set("currNode",r)})}decrement(e){if(this.checkNode(e),!(this.getIn(["nodes",e])instanceof a))throw new Error(`node can not be decremented: ${e}`);const t=this.saveState().withMutations(function(t){t.updateNode(e)});return t.getIn(["nodes",e])===r?t.withMutations(function(t){const n=t.getIn(["nodes",e,o.EMP]);t.set("currNode",n)}):t.withMutations(function(t){t.updateIn(["nodes",e,"val"],e=>e-1);const n=t.getIn(["nodes",e,"register"]),s=t.getIn(["nodes",e,"val"]);t.setIn(["registers",n],s);const r=t.getIn(["nodes",e,o.DEC]);t.set("currNode",r)})}setStart(e){return this.checkNode(e),this.set("currNode",e)}setTime(e){const t=this.get("states").size(e+1);return this.getIn(["states",e]).set("states",t)}prevStep(){const e=this.get("states").size-2;return this.setTime(e)}nextStep(){const e=this.get("currNode"),t=this.getIn(["nodes",e]);return t===i?this:t instanceof d?this.increment(e):t instanceof a?this.decrement(e):void 0}run(){let e=this;for(;e.currNode!==i;)e=e.nextStep();return e.get("registers")}},e.PlusNode=d,e.MinusNode=a,Object.defineProperty(e,"__esModule",{value:!0})});
