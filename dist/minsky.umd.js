!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t(e.minksy={})}(this,function(e){"use strict";const{List:t,Map:n,Record:s}=require("immutable"),r=0,i=null,o={EMP:"empty",INC:"increment",DEC:"decrement"};class u extends(s({value:null,register:null})){constructor({value:e,register:t}={}){if(e<r)throw new Error("value in PlusNode must be greater than or equal to 0");super({value:e,register:t})}}class d extends(s({value:null,register:null})){constructor({value:e,register:t}={}){if(e<r)throw new Error("value in MinusNode must be greater than or equal to 0");super({value:e,register:t})}}e.empty=r,e.halt_node=void 0,e.haltNode=i,e.linkType=o,e.RegisterMachine=class extends(s({nodes:n(),registers:n(),links:n(),states:t(),currNode:i})){addNode(e,t){if(t instanceof u)return this.withMutations(function(n){n.setIn(["nodes",e],t),n.setIn(["links",e,o.INC],i),n.setIn(["registers",t.get("register")],null)});if(t instanceof d)return this.withMutations(function(n){n.setIn(["nodes",e],t),n.setIn(["links",e,o.EMP],i),n.setIn(["links",e,o.DEC],i),n.setIn(["registers",t.get("register")],null)});throw new Error(`invalid node type: ${t.constructor.name}`)}addLink(e,t,n){let s=!1;for(let t in o)if(o[t]===e){s=!0;break}if(!s)throw new Error(`invalid transition type: ${e.constructor.name}`);return this.checkNode(t),this.checkNode(n),this.setIn(["links",t,e],n)}checkNode(e){if(!this.nodes.has(e))throw new Error(`register machine does not have node named: ${e}`)}saveState(){return this.update("states",e=>e.push(this.remove("states")))}updateNode(e){const t=this.getIn(["nodes",e,"register"]);if(null===this.getIn(["nodes",e,"value"])){const n=this.getIn(["registers",t]);return this.setIn(["nodes",e,"value"],n)}return this}updateRegister(e){const t=this.getIn(["nodes",e,"value"]),n=this.getIn(["nodes",e,"register"]);return this.setIn(["registers",n],t)}increment(e){if(this.checkNode(e),!(this.getIn(["nodes",e])instanceof u))throw new Error(`node can not be incremented: ${e}`);return this.saveState().withMutations(function(t){t.updateNode(e),t.updateIn(["nodes",e,"value"],e=>e+1),t.updateRegister(e);const n=t.getIn(["links",e,o.INC]);t.set("currNode",n)})}decrement(e){if(this.checkNode(e),!(this.getIn(["nodes",e])instanceof d))throw new Error(`node can not be decremented: ${e}`);const t=this.saveState().withMutations(function(t){t.updateNode(e)});return t.getIn(["nodes",e,"value"])===r?t.withMutations(function(t){t.updateRegister(e);const n=t.getIn(["links",e,o.EMP]);t.set("currNode",n)}):t.withMutations(function(t){t.updateIn(["nodes",e,"value"],e=>e-1),t.updateRegister(e);const n=t.getIn(["links",e,o.DEC]);t.set("currNode",n)})}setStart(e){return this.checkNode(e),this.set("currNode",e)}setTime(e){const t=this.get("states").size(e+1);return this.getIn(["states",e]).set("states",t)}prevStep(){const e=this.get("states").size-2;return this.setTime(e)}nextStep(){const e=this.get("currNode"),t=this.getIn(["nodes",e]);return t===i?this:t instanceof u?this.increment(e):t instanceof d?this.decrement(e):void 0}run(){let e=this;for(;e.currNode!==i;)e=e.nextStep();return e.get("registers")}},e.PlusNode=u,e.MinusNode=d,Object.defineProperty(e,"__esModule",{value:!0})});
